# Recursion
# calculate sum of a list
def listsum(numlist):
    theSum = 0
    for i in numlist:
        theSum = theSum + i
    return theSum

def listsum(numList):
    if len(numList) == 1:
        return numList[0]
    else:
        return numList[0] + listsum(numList[1:])
        
# 3 laws of recursion - 
# a) a recursive algorithm must have a base case
# b) a recursive algorithm must change its state and move toward the base case
# c) a recursive algorithm must call itself, recursively

def toStr(n, base):
    convertString = '0123456789ABCDEF'
    if n < base:
        return convertString[n]
    else:
        return toStr(n // base, base) + convertString[n%base]

def reverse(s):
    if len(s) == 0:
        return 0
    else:
        return reverse(s[1:] + s[0])

def palindrom(st):
    for i in range(len(st)//2):
        if st[i] != st[-1-i]:
            return False
    return True
    
    
# Stack Frames: 
rStack = Stack()
def toStr(n, base):
    convertString = '0123456789ABCDEF'
    while n > 0:
        if n < base:
            rStack.push(convertString[n])
        else:
            rStack.push(convertString[n%base])
        n = n // base
    res = ''
    while not rStack.isEmpty():
        res = res + str(rStack.pop())
    return(res)
    
    
    
# Visualizing Recursion  
import turtle
myTurtle = turtle.Turtle()
myWin = turtle.Screen()
def drawSpiral(myTurtle, lineLen):
    if lineLen > 0:
        myTurtle.forward(lineLen)
        myTurtle.right(90)
        drawSpiral(myTurtle, lineLen -5)

drawSpiral(myTurtle,100)
        
myWin.exitonclick()



import turtle
def drawTriangle(points, color, myTurtle):
    myTurtle.fillcolor(color)
    myTurtle.up()
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.down()
    myTurtle.begin_fill()
    myTurtle.goto(points[1][0],points[1][1])
    myTurtle.goto(points[2][0],points[2][1])
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.end_fill()
    
def getMid(p1, p2):
    return ( (p1[0]+p2[0])/2, (p1[1]+p2[1])/2 )
    
def sierpinski(points,degree,myTurtle):
    colormap = ['blue','red','green','white','yellow',
                'violet','orange']
    drawTriangle(points,colormap[degree],myTurtle)
    if degree > 0:
        sierpinski([points[0],
                        getMid(points[0], points[1]),
                        getMid(points[0], points[2])],
                   degree-1, myTurtle)
        sierpinski([points[1],
                        getMid(points[0], points[1]),
                        getMid(points[1], points[2])],
                   degree-1, myTurtle)
        sierpinski([points[2],
                        getMid(points[2], points[1]),
                        getMid(points[0], points[2])],
                   degree-1, myTurtle)

def main():
   myTurtle = turtle.Turtle()
   myWin = turtle.Screen()
   myPoints = [[-100,-50],[0,100],[100,-50]]
   sierpinski(myPoints,3,myTurtle)
   myWin.exitonclick()

main()
    
    
# Tower of Hanoi
def moveTower(height, fromPole, toPole, withPole):
    if height > 1:
        moveTower(height - 1, fromPole, toPole, withPole)
        moveDisk(fromPole, toPole)
        moveTower(height - 1, withPole, toPole, fromPole)


def moveDisk(fp, tp):
        print("moving disk from",fp,"to",tp)





class Maze:
        def __init__(self, mazeFileName):
                rowsInMaze = 0
                columnsInMaze = 0
                self.mazelist = []
                mazeFile = open(mazeFileName, 'r')
                s = []
                for i in mazeFile:
                        rowList = []
                        col = 0
                        for j in i[:-1]:
                                rowList.append(j)
                                if j == 'S':
                                        self.startRow = rowInMaze
                                        self.startCol = col
                                col = col + 1
                        rowsInMaze = rowsInMaze + 1
                        self.mazelist.append(rowList)
                        columnsInMaze = len(rowList)
                        
                 self.rowsInMaze = rowsInMaze
                 self.columnsInMaze = columnsInMaze
                 self.xTranslate = -columnsInMaze/2
                 self.yTranslate = rowsInMaze/2
                 self.t = Turtle(shape='turtle')
                 setup(width=600,height=600)
                 setworldcoordinates(-(columnsInMaze-1)/2-.5,
                                    -(rowsInMaze-1)/2-.5,
                                    (columnsInMaze-1)/2+.5,
                                    (rowsInMaze-1)/2+.5)
                                    
                                    
        def drawCenteredBox(self, x, y, color):
                tracer(0)
                self.t.up()
                self.t.goto(x-.5, y-.5)
                self.t.color('black',color)
                self.t.setheading(90)
                self.t.down()
                self.t.begin_fill()
                for i in range(4):
                        self.t.forward(1)
                        self.t.right(90)
                self.t.end_fill()
                update()
                tracer(1)
        def moveTurtle(self, x, y):
                self.t.up()
                self.t.setheading(self, t.toward(x+self.xTranslate, -y+self.yTranslate))
                self.t.goto(x+self.xTranslate, -y+self.yTranslate)
                
        def dropBreadcrumb(self,color):
                self.t.dot(color)
        def updatePosition(self,row, col, val = None):
                if val:
                        self.mazelist[row][col] = val
                self.moveTurtle(col, row)
                if val == PART_OF_PATH:
                        color = 'green'
                elif val == OBSTACLE:
                        color = 'red'
                elif val == TIRED:
                        color = 'black'
                elif val == DEAD_END:
                        color = 'red'
                else:
                        color = None
                if color:
                        self.dropBreadcrumb(color)
                        
                        
        def isExit(self, row, col):
                return(row ==0 or row==self.rowsInMaze - 1 or col = 0 or col == self.columnsInMaze -1)
        def __getitem__(self,idx):
                return self.mazelist[idx]
                
                
def searchFrom(maze, startRow, startColumn):
    # try each of four directions from this point until we find a way out.
    # base Case return values:
    #  1. We have run into an obstacle, return false
    maze.updatePosition(startRow, startColumn)
    if maze[startRow][startColumn] == OBSTACLE :
        return False
    #  2. We have found a square that has already been explored
    if maze[startRow][startColumn] == TRIED or maze[startRow][startColumn] == DEAD_END:
        return False
    # 3. We have found an outside edge not occupied by an obstacle
    if maze.isExit(startRow,startColumn):
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
        return True
    maze.updatePosition(startRow, startColumn, TRIED)
    # Otherwise, use logical short circuiting to try each direction
    # in turn (if needed)
    found = searchFrom(maze, startRow-1, startColumn) or \
            searchFrom(maze, startRow+1, startColumn) or \
            searchFrom(maze, startRow, startColumn-1) or \
            searchFrom(maze, startRow, startColumn+1)
    if found:
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
    else:
        maze.updatePosition(startRow, startColumn, DEAD_END)
    return found

              
